{"version":3,"sources":["../webpack/bootstrap","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","Models/Tile.ts","Confirmers/Confirmer.ts","Solvers/SolverUtil.ts","Solvers/ColumnPoints.ts","Solvers/RowPoints.ts","Solvers/CountPoints.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js","Library/wordHandler.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","Solvers/ColumnSolver.ts","Solvers/RowSolver.ts","Solvers/solver.worker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_arrayLikeToArray","arr","len","length","arr2","Array","_toConsumableArray","isArray","iter","iterator","from","minLen","toString","slice","constructor","test","TypeError","_defineProperty","obj","configurable","writable","ownKeys","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","SpecialTile","words","isStartOfHorizontalWord","row","column","board","char","isStartOfVerticalWord","getHorizontalWord","lastColumnOfWord","word","getVerticalWord","lastRowOfWord","totalNumberOfCharsInBoard","count","hasVisited","visited","some","visit","searchLabyrint","canGoRight","canGoUp","canGoDown","canGoLeft","isWord","item","boardIsValid","wordsAreConnected","invalidWords","sequenceMatch","libraryWord","constructedWord","split","every","index","reduce","prev","current","isWordFine","playerChars","libraryWordStartInConstructedWord","getStartOfMatchingSequence","missingCharacters","startInConstructedWord","getMissingCharacters","missing","playerCharacters","temp","indexOf","splice","missingCharactersInPlayerCharacters","hasChar","CharacterPoints","columnPoints","TL","TW","DL","DW","matchedWord","points","countCharPoint","currentPoints","columnWord","countWordPoint","specials","countColumnPoints","wordsFound","matchedWords","direction","hasNotFinalCharacter","final","findColumnWords","previous","rowPoints","rowWord","countRowPoints","findRowWords","getCharPoint","findIndex","cList","includes","tile","special","countPoints","_defineProperties","props","descriptor","WordHandler","instance","Constructor","_words","getWordsWithAtLeastLength","monkey","flat","this","englishWords_2","englishWords_3","englishWords_4","englishWords_5","englishWords_6","englishWords_7","englishWords_8","englishWords_9","englishWords_10","englishWords_11","englishWords_12","englishWords_13","englishWords_14","englishWords_15","englishWords_16","englishWords_17","englishWords_18","englishWords_19","englishWords_20","englishWords_21","englishWords_22","englishWords_23","englishWords_24","englishWords_25","protoProps","staticProps","_instance","getConstructedWordFromBoard","payload","charsUsed","start","playerCharsLength","splitted","wordsThatMatchPositions","allWords","accumulated","columnMatch","solve","result","matches","Instance","wordIsValidInBoard","map","countPointsHelper","setWordInBoard","removeWordFromBoard","isValid","rowMatch","error","console","log","chars","list","solveColumns","solveRows","postMessage"],"mappings":"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","file":"44549db59f1a55d76971.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/wordfeud-helper/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 25);\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","export enum SpecialTile {\r\n  DL = 'dl',\r\n  TL = 'tl',\r\n  DW = 'dw',\r\n  TW = 'tw',\r\n}\r\n\r\nexport interface Position {\r\n  row: number,\r\n  column: number,\r\n}\r\n\r\nexport interface NewTile extends Position{\r\n  char: string,\r\n}\r\n\r\nexport interface Tile {\r\n  final: boolean;\r\n  special: SpecialTile | null,\r\n  char: string,\r\n  playerChar?: boolean,\r\n  error?: boolean\r\n}\r\n\r\nexport const finalTile = (char: string = ''): Tile => {\r\n  return { char, special: null, final: char !== '' }\r\n}\r\n\r\nexport const notFinalTile = (char: string = ''): Tile => {\r\n  return { char, special: null, final: false }\r\n}\r\n\r\nexport interface SolveTile extends Position {\r\n  start: number;\r\n  length: number,\r\n  char: string,\r\n}\r\n\r\n/**\r\n * \"final: false\" a character in the word is not final which means\r\n * this word is not finished.\r\n */\r\nexport interface MatchedWord extends Position {\r\n  word: string,\r\n  points: number,\r\n  direction: 'row' | 'column',\r\n  hasNotFinalCharacter?: boolean,\r\n}\r\n\r\nexport const AllowedChars: Array<string> = ['backspace', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\r\n\r\nexport const CharacterPoints: Array<Array<string>> = [\r\n  /* 0*/[],\r\n  /* 1*/['a', 'e', 'i', 'l', 'n', 'o', 'r', 's', 't'],\r\n  /* 2*/['d', 'u'],\r\n  /* 3*/['g', 'm'],\r\n  /* 4*/['b', 'c', 'f', 'h', 'p', 'v', 'w', 'y'],\r\n  /* 5*/['k'],\r\n  /* 6*/[],\r\n  /* 7*/[],\r\n  /* 8*/['x'],\r\n  /* 9*/[],\r\n  /*10*/['j', 'q', 'z']\r\n];\r\n\r\nexport const StartBoard: Array<Array<Tile>> = [\r\n  [{final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}],\r\n  [{final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}],\r\n  [{final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}],\r\n  [{final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}],\r\n  [{final: false, special: SpecialTile.TW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TW, char: ''}],\r\n  [{final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}],\r\n  [{final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}],\r\n  [{final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}],\r\n  [{final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}],\r\n  [{final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}],\r\n  [{final: false, special: SpecialTile.TW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TW, char: ''}],\r\n  [{final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}],\r\n  [{final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}],\r\n  [{final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}],\r\n  [{final: false, special: SpecialTile.TL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.DL, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TW, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: null, char: ''}, {final: false, special: SpecialTile.TL, char: ''}]\r\n];","import { Tile, Position } from '../Models/Tile';\r\nimport englishWords from '../Words.json';\r\n\r\nconst words: Array<string> = englishWords as Array<string>;\r\n\r\nconst isStartOfHorizontalWord = (row: number, column: number, board: Array<Array<Tile>>) => {\r\n  // No char in this tile\r\n  if (board[row][column].char === '') {\r\n    return false;\r\n  }\r\n\r\n  // At the start of the board and tile to right is a char\r\n  if (column === 0) {\r\n    if (board[row][column + 1].char !== '') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // At the end of the board\r\n  if (column === board[0].length - 1) {\r\n    return false;\r\n  }\r\n\r\n  // Somewhere in the board where there is no char to the left but one to the right\r\n  if (board[row][column - 1].char === '' && board[row][column + 1].char !== '') {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nconst isStartOfVerticalWord = (row: number, column: number, board: Array<Array<Tile>>) => {\r\n    // No char in this tile\r\n    if (board[row][column].char === '') {\r\n      return false;\r\n    }\r\n\r\n  // At the start of the board and a char is beneath this tile\r\n  if (row === 0) {\r\n    if (board[row + 1][column].char !== '') {\r\n      return true\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // At the end of the board\r\n  if (row === board[0].length - 1) {\r\n    return false;\r\n  }\r\n\r\n  // Somewhere in the board where there is no char above but there is one beneath\r\n  if (board[row - 1][column].char === '' && board[row + 1][column].char !== '') {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Do this after we know that this tile is the start of horizontal word\r\n */\r\nconst getHorizontalWord = (row: number, column: number, board: Array<Array<Tile>>) => {\r\n  let lastColumnOfWord = column;\r\n  let word = '';\r\n\r\n  while (lastColumnOfWord < board[0].length && board[row][lastColumnOfWord].char !== '') {\r\n    word += board[row][lastColumnOfWord].char;\r\n    lastColumnOfWord += 1;\r\n  }\r\n\r\n  return word;\r\n}\r\n\r\n/**\r\n * Do this after we know that this tile is the start of vertical word\r\n */\r\nconst getVerticalWord = (row: number, column: number, board: Array<Array<Tile>>) => {\r\n  let lastRowOfWord = row;\r\n  let word = '';\r\n\r\n  while (lastRowOfWord < board[0].length && board[lastRowOfWord][column].char !== '') {\r\n    word += board[lastRowOfWord][column].char;\r\n    lastRowOfWord += 1;\r\n    if (lastRowOfWord > 100) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return word;\r\n}\r\n\r\nconst canGoLeft = (row: number, column: number, board: Array<Array<Tile>>) => {\r\n  return column - 1 > 0 && board[row][column - 1].char !== '';\r\n}\r\n\r\nconst canGoRight = (row: number, column: number, board: Array<Array<Tile>>) => {\r\n  return column + 1 < board.length && board[row][column + 1].char !== '';\r\n}\r\n\r\nconst canGoUp = (row: number, column: number, board: Array<Array<Tile>>) => {\r\n  return row - 1 > 0 && board[row - 1][column].char !== '';\r\n}\r\n\r\nconst canGoDown = (row: number, column: number, board: Array<Array<Tile>>) => {\r\n  return row + 1 < board.length && board[row + 1][column].char !== '';\r\n}\r\n\r\nconst totalNumberOfCharsInBoard = (board: Array<Array<Tile>>) => {\r\n  let count = 0;\r\n  for (let row = 0; row < board.length; row++) {\r\n    for (let column = 0; column < board[row].length; column++) {\r\n      if (board[row][column].char !== '') {\r\n        count += 1;\r\n      }\r\n    }\r\n  }\r\n  return count;\r\n}\r\n\r\nconst hasVisited = (row: number, column: number, visited: Array<Position>) => {\r\n  return visited.some(visit => visit.row === row && visit.column === column)\r\n}\r\n\r\nconst searchLabyrint = (row: number, column: number, board: Array<Array<Tile>>, visited: Array<Position>, count: number) => {\r\n  if (canGoRight(row, column, board) && !hasVisited(row, column + 1, visited)) {\r\n    visited.push({ row: row, column: column + 1 })\r\n    count = searchLabyrint(row, column + 1, board, visited, count + 1)\r\n  }\r\n\r\n  if (canGoUp(row, column, board) && !hasVisited(row - 1, column, visited)) {\r\n    visited.push({ row: row - 1, column: column })\r\n    count = searchLabyrint(row - 1, column, board, visited, count + 1)\r\n  }\r\n\r\n  if (canGoDown(row, column, board) && !hasVisited(row + 1, column, visited)) {\r\n    visited.push({ row: row + 1, column: column })\r\n    count = searchLabyrint(row + 1, column, board, visited, count + 1)\r\n  }\r\n\r\n  if (canGoLeft(row, column, board) && !hasVisited(row, column - 1, visited)) {\r\n    visited.push({ row: row, column: column - 1 })\r\n    count = searchLabyrint(row, column - 1, board, visited, count + 1)\r\n  }\r\n\r\n  return count\r\n}\r\n\r\nconst wordsAreConnected = (board: Array<Array<Tile>>) => {\r\n  for (let row = 0; row < board.length; row++) {\r\n    for (let column = 0; column < board[row].length; column++) {\r\n      if (board[row][column].char !== '') {\r\n        return searchLabyrint(row, column, board, [{row, column}], 1) === totalNumberOfCharsInBoard(board)\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nconst isWord = (word: string) => {\r\n  return words.some(item => item === word);\r\n}\r\n\r\n/**\r\n * Returns list of invalid words\r\n */\r\nconst boardIsValid = (board: Array<Array<Tile>>) => {\r\n  if (!wordsAreConnected(board)) {\r\n    return false;\r\n  }\r\n\r\n  const invalidWords = [];\r\n  for (let row = 0; row < board.length; row++) {\r\n    for (let column = 0; column < board[0].length; column++) {\r\n      if (isStartOfHorizontalWord(row, column, board)) {\r\n        const word = getHorizontalWord(row, column, board)\r\n        if (!isWord(word)) {\r\n          invalidWords.push(word)\r\n        }\r\n      }\r\n\r\n      if (isStartOfVerticalWord(row, column, board)) {\r\n        const word = getVerticalWord(row, column, board)\r\n        \r\n        if (!isWord(word)) {\r\n          invalidWords.push(word)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  return invalidWords.length === 0;\r\n}\r\n\r\n\r\n\r\n\r\nexport {\r\n  isStartOfHorizontalWord,\r\n  isStartOfVerticalWord,\r\n  getHorizontalWord,\r\n  getVerticalWord,\r\n  boardIsValid,\r\n  wordsAreConnected,\r\n}","import { MatchedWord, Tile } from \"../Models/Tile\";\r\n\r\nconst createArray = (total: number): Array<number> => {\r\n  return Array.from(Array(total).keys())\r\n}\r\n\r\nconst hasJokerAndRemoveJoker = (chars: Array<string>) => {\r\n  const index = chars.indexOf('*')\r\n  if (index >= 0) {\r\n    chars.splice(index, 1)\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\nconst matchedWordMatchesWord = (combinedChars: string, word: string) => {\r\n  let copiedChars = combinedChars.split('')\r\n  return word.split('').every((charInWord) => {\r\n    const index = copiedChars.indexOf(charInWord)\r\n    if (index >= 0) {\r\n      copiedChars.splice(index, 1)\r\n      return true\r\n    } else {\r\n      return hasJokerAndRemoveJoker(copiedChars)\r\n    }\r\n  });\r\n}\r\n\r\nconst sortByPoints = (matchedWords: Array<MatchedWord>): Array<MatchedWord> => {\r\n  return matchedWords.sort((a, b) => b.points - a.points)\r\n}\r\n\r\n/**\r\n * libraryWord matches constructedWord with constructedWord being able to contain *\r\n * which are all characters.\r\n * @param libraryWord \r\n * @param constructedWord \r\n */\r\nconst sequenceMatch = (libraryWord: string, constructedWord: string): boolean => {\r\n  if (libraryWord.length > 0 && constructedWord.length > 0) {\r\n    if (libraryWord.split('').every((char, index) => constructedWord[index] === '*' || char === constructedWord[index])) {\r\n      const allCharactersShouldNotBeStars = libraryWord\r\n        .split('')\r\n        .reduce((prev, current, index) => {\r\n          if (constructedWord[index] === '*' || current === constructedWord[index]) {\r\n            return [...prev, constructedWord[index]];\r\n          }\r\n          return prev;\r\n        }, [] as Array<string>);\r\n\r\n      return allCharactersShouldNotBeStars.some(char => char !== '*');\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nconst getStartOfMatchingSequence = (libraryWord: string, constructedWord: string): number => {\r\n  let index = 0;\r\n  while (index < constructedWord.length) {\r\n    if (sequenceMatch(libraryWord, constructedWord.slice(index))) {\r\n      return index;\r\n    }\r\n    index++;\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nconst getMissingCharacters = (libraryWord: string, constructedWord: string, startInConstructedWord: number): string => {\r\n  return constructedWord\r\n    .split('')\r\n    .slice(startInConstructedWord)\r\n    .reduce((prev, current, index) => {\r\n      // (libraryWordAsArray[index] || '') is needed if constructedWord is longer\r\n      return current === '*' ? prev + (libraryWord[index] || '') : prev;\r\n  }, '');\r\n}\r\n\r\nconst missingCharactersInPlayerCharacters = (missing: string, playerCharacters: string): boolean => {\r\n  let temp = playerCharacters.split('');\r\n  return missing.split('').every(char => {\r\n    const index = temp.indexOf(char);\r\n    if (index >= 0) {\r\n      temp.splice(index, 1);\r\n      return true;\r\n    }\r\n    return false;\r\n  })\r\n}\r\n\r\nconst isWordFine = (libraryWord: string, constructedWord: string, playerChars: string):boolean => {\r\n   // Get start of matching sequence of the constructedWord against the libraryWord\r\n   const libraryWordStartInConstructedWord = getStartOfMatchingSequence(libraryWord, constructedWord);\r\n   if (libraryWordStartInConstructedWord >= 0) {\r\n     // Check that the previous character in the constructedWord is a * or that we are at the beginning of the word\r\n     if (libraryWordStartInConstructedWord === 0 || constructedWord.split('')[libraryWordStartInConstructedWord - 1] === '*') {\r\n       // Get the missing characters we dont have in the constructedWord\r\n       const missingCharacters = getMissingCharacters(libraryWord, constructedWord, libraryWordStartInConstructedWord);\r\n       if (missingCharacters !== '') {\r\n         // check that the missing characters are in players characters list\r\n         if (missingCharactersInPlayerCharacters(missingCharacters, playerChars)) {\r\n           return true;\r\n         }\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nconst hasChar = (board: Array<Array<Tile>>, row: number, column: number): boolean => {\r\n  return board[row][column].char !== '';\r\n}\r\n\r\nexport {\r\n  createArray,\r\n  hasJokerAndRemoveJoker,\r\n  sortByPoints,\r\n  matchedWordMatchesWord,\r\n  hasChar,\r\n  sequenceMatch,\r\n  getStartOfMatchingSequence,\r\n  getMissingCharacters,\r\n  missingCharactersInPlayerCharacters,\r\n  isWordFine\r\n}","import { MatchedWord, Tile } from \"../Models/Tile\";\r\nimport { countCharPoint, countWordPoint } from \"./CountPoints\";\r\n\r\nconst specials = (currentPoints: number, columnWord: MatchedWord, board: Array<Array<Tile>>) => {\r\n  let points = currentPoints;\r\n  for (let i = 0; i < columnWord.word.length; i++) {\r\n    points = countWordPoint(currentPoints, board[columnWord.row + i][columnWord.column])\r\n  }\r\n\r\n  return points\r\n}\r\n\r\nconst columnPoints = (matchedWord: MatchedWord, board: Array<Array<Tile>>): number => {\r\n  let points = 0;\r\n  for (let i = 0; i < matchedWord.word.length; i++) {\r\n    points += countCharPoint(board[matchedWord.row + i][matchedWord.column], matchedWord.word[i]);\r\n  }\r\n\r\n  return specials(points, matchedWord, board);\r\n}\r\n\r\nconst findColumnWords = (board: Array<Array<Tile>>): Array<MatchedWord> => {\r\n  const wordsFound: Array<MatchedWord> = []\r\n\r\n  for (let column = 0; column < board.length; column++) {\r\n    const matchedWords: Array<MatchedWord> = [{\r\n      word: '', points: 0, direction: 'column', column, row: -1, hasNotFinalCharacter: false,\r\n    }];\r\n    \r\n    for (let row = 0; row < board.length; row++) {\r\n      if (board[row][column].char === '') {\r\n        if (matchedWords[matchedWords.length - 1].word.length > 0) {\r\n          matchedWords.push({ word: '', points: 0, direction: 'column', column, row: -1, hasNotFinalCharacter: false })\r\n        }\r\n      } else {\r\n        if (matchedWords[matchedWords.length - 1].row === -1) {\r\n          matchedWords[matchedWords.length - 1].row = row;\r\n        }\r\n\r\n        matchedWords[matchedWords.length - 1].word += board[row][column].char;\r\n        matchedWords[matchedWords.length - 1].hasNotFinalCharacter =\r\n          matchedWords[matchedWords.length - 1].hasNotFinalCharacter || !board[row][column].final;\r\n      }\r\n    }\r\n    // Word has to be at least 2 characters and contain one character that is not final\r\n    wordsFound.push(...matchedWords.filter(matchedWord => matchedWord.word.length > 1 && matchedWord.hasNotFinalCharacter))\r\n  }\r\n\r\n  return wordsFound.filter(matchedWord => matchedWord.row >= 0)\r\n}\r\n\r\nconst countColumnPoints = (board: Array<Array<Tile>>): number => {\r\n  const wordsFound: Array<MatchedWord> = findColumnWords(board)\r\n  return wordsFound.reduce((previous, current) => {\r\n    return previous + columnPoints(current, board)\r\n  }, 0);\r\n}\r\n\r\nexport {\r\n  countColumnPoints,\r\n  findColumnWords,\r\n}","import { MatchedWord, Tile } from \"../Models/Tile\";\r\nimport { countWordPoint, countCharPoint } from './CountPoints';\r\n\r\nconst specials = (currentPoints: number, rowWord: MatchedWord, board: Array<Array<Tile>>) => {\r\n  let points = currentPoints;\r\n  for (let i = 0; i < rowWord.word.length; i++) {\r\n    points = countWordPoint(currentPoints, board[rowWord.row][rowWord.column + i])\r\n  }\r\n\r\n  return points\r\n}\r\n\r\nconst rowPoints = (rowWord: MatchedWord, board: Array<Array<Tile>>): number => {\r\n  let points = 0;\r\n  for (let i = 0; i < rowWord.word.length; i++) {\r\n    points += countCharPoint(board[rowWord.row][rowWord.column + i], rowWord.word[i]);\r\n  }\r\n\r\n  return specials(points, rowWord, board);\r\n}\r\n\r\nconst findRowWords = (board: Array<Array<Tile>>): Array<MatchedWord> => {\r\n  const wordsFound: Array<MatchedWord> = [];\r\n\r\n  for (let row = 0; row < board.length; row++) {\r\n    const matchedWords: Array<MatchedWord> = [{\r\n      word: '', points: 0, direction: 'row', row, column: -1, hasNotFinalCharacter: false,\r\n    }];\r\n\r\n    for (let column = 0; column < board.length; column++) {\r\n      if (board[row][column].char === '') {\r\n        if (matchedWords[matchedWords.length - 1].word.length > 0) {\r\n          matchedWords.push({ word: '', points: 0, direction: 'row', column: -1, row, hasNotFinalCharacter: false })\r\n        }\r\n      } else {\r\n        if (matchedWords[matchedWords.length - 1].column === -1) {\r\n          matchedWords[matchedWords.length - 1].column = column;\r\n        }\r\n\r\n        matchedWords[matchedWords.length - 1].word += board[row][column].char;\r\n        matchedWords[matchedWords.length - 1].hasNotFinalCharacter =\r\n          matchedWords[matchedWords.length - 1].hasNotFinalCharacter || !board[row][column].final;\r\n      }\r\n    }\r\n    wordsFound.push(...matchedWords.filter(matchedWord => matchedWord.word.length > 1 && matchedWord.hasNotFinalCharacter))\r\n  }\r\n\r\n  return wordsFound;\r\n}\r\n\r\nconst countRowPoints = (board: Array<Array<Tile>>) => {\r\n  const wordsFound: Array<MatchedWord> = findRowWords(board)\r\n\r\n  return wordsFound.reduce((previous, current) => {\r\n    return previous + rowPoints(current, board)\r\n  }, 0)\r\n}\r\n\r\nexport {\r\n  countRowPoints,\r\n  findRowWords,\r\n}","import { CharacterPoints, Tile } from \"../Models/Tile\"\r\nimport { countColumnPoints } from \"./ColumnPoints\"\r\nimport { countRowPoints } from \"./RowPoints\"\r\n\r\nconst getCharPoint = (char: string) => {\r\n  return CharacterPoints.findIndex(cList => cList.includes(char))\r\n}\r\n\r\nconst countCharPoint = (tile: Tile, char: string) => {\r\n  if (!tile.final) {\r\n    if ('dl' === tile.special) {\r\n      return getCharPoint(char) * 2\r\n    }\r\n    if ('tl' === tile.special) {\r\n      return getCharPoint(char) * 3\r\n    }\r\n  }\r\n\r\n  return getCharPoint(char)\r\n}\r\n\r\nconst countWordPoint = (currentPoints: number, tile: Tile): number => {\r\n  if (!tile.final) {\r\n    if (tile.special === 'dw') {\r\n      return currentPoints *= 2;\r\n    }\r\n  \r\n    if (tile.special === 'tw') {\r\n      return currentPoints *= 3;\r\n    } \r\n  }\r\n\r\n  return currentPoints\r\n}\r\n\r\nconst countPoints = (board: Array<Array<Tile>>): number => {\r\n  const column = countColumnPoints(board)\r\n  const row = countRowPoints(board)\r\n\r\n  return column + row\r\n}\r\n\r\nexport {\r\n  countCharPoint,\r\n  countWordPoint,\r\n  countPoints\r\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","import englishWords_2 from './English/englishWords_2.json';\r\nimport englishWords_3 from './English/englishWords_3.json';\r\nimport englishWords_4 from './English/englishWords_4.json';\r\nimport englishWords_5 from './English/englishWords_5.json';\r\nimport englishWords_6 from './English/englishWords_6.json';\r\nimport englishWords_7 from './English/englishWords_7.json';\r\nimport englishWords_8 from './English/englishWords_8.json';\r\nimport englishWords_9 from './English/englishWords_9.json';\r\nimport englishWords_10 from './English/englishWords_10.json';\r\nimport englishWords_11 from './English/englishWords_11.json';\r\nimport englishWords_12 from './English/englishWords_12.json';\r\nimport englishWords_13 from './English/englishWords_13.json';\r\nimport englishWords_14 from './English/englishWords_14.json';\r\nimport englishWords_15 from './English/englishWords_15.json';\r\nimport englishWords_16 from './English/englishWords_16.json';\r\nimport englishWords_17 from './English/englishWords_17.json';\r\nimport englishWords_18 from './English/englishWords_18.json';\r\nimport englishWords_19 from './English/englishWords_19.json';\r\nimport englishWords_20 from './English/englishWords_20.json';\r\nimport englishWords_21 from './English/englishWords_21.json';\r\nimport englishWords_22 from './English/englishWords_22.json';\r\nimport englishWords_23 from './English/englishWords_23.json';\r\nimport englishWords_24 from './English/englishWords_24.json';\r\nimport englishWords_25 from './English/englishWords_25.json';\r\n\r\nexport class WordHandler {\r\n  private static _instance: WordHandler;\r\n  private _words: Array<Array<string>> = [];\r\n\r\n  private constructor() {\r\n    this._words = [\r\n      englishWords_2,\r\n      englishWords_3,\r\n      englishWords_4,\r\n      englishWords_5,\r\n      englishWords_6,\r\n      englishWords_7,\r\n      englishWords_8,\r\n      englishWords_9,\r\n      englishWords_10,\r\n      englishWords_11,\r\n      englishWords_12,\r\n      englishWords_13,\r\n      englishWords_14,\r\n      englishWords_15,\r\n      englishWords_16,\r\n      englishWords_17,\r\n      englishWords_18,\r\n      englishWords_19,\r\n      englishWords_20,\r\n      englishWords_21,\r\n      englishWords_22,\r\n      englishWords_23,\r\n      englishWords_24,\r\n      englishWords_25,\r\n    ]\r\n  }\r\n\r\n  public static get Instance() {\r\n      return this._instance || (this._instance = new this());\r\n  }\r\n\r\n  getWordsWithAtLeastLength = (length: number): Array<string> => {\r\n    if (length < 2 || length > 25) {\r\n      return [];\r\n    }\r\n\r\n    const result = this._words\r\n    .filter(monkey => monkey[0].length <= length)\r\n    .flat(1);\r\n\r\n    return result;\r\n  }\r\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","import { MatchedWord, Tile } from \"../Models/Tile\";\r\nimport { boardIsValid } from \"../Confirmers/Confirmer\";\r\nimport { hasChar, isWordFine } from './SolverUtil';\r\nimport { countPoints } from \"./CountPoints\";\r\nimport { WordHandler } from \"../Library/wordHandler\";\r\n\r\nexport interface ColumnMatch {\r\n  allWords: Array<string>;\r\n  constructedWord: string; // Could be *be*apa  [][b][e][][a][p][a];\r\n  playerChars: string;\r\n  board: Array<Array<Tile>>;\r\n  row: number;\r\n  column: number;\r\n}\r\n\r\n/**\r\n * Find the word position in the board.\r\n * And get position of the characters in the board\r\n * If we have start: 1\r\n * and board:\r\n * [][a][][b][c][]\r\n * and playerCharsLength: 2 // user has 2 characters\r\n * we will get\r\n * constructedWord: a*bc*\r\n * maxLength: 5 // we start at a and can only go to after b because the board ends\r\n * @param payload\r\n */\r\nconst getConstructedWordFromBoard = (payload: {\r\n  board: Array<Array<Tile>>, start: number, playerCharsLength: number, column: number\r\n}): string => {\r\n  let charsUsed = 0;\r\n  let row = payload.start;\r\n  let constructedWord: string = '';\r\n  let index = 0;\r\n\r\n  for (; row < payload.board.length; row++, index++) {\r\n    if (hasChar(payload.board, row, payload.column)) {\r\n      constructedWord += payload.board[row][payload.column].char;\r\n      continue;\r\n    }\r\n  \r\n    if (charsUsed < payload.playerCharsLength) {\r\n      constructedWord += '*';\r\n    }\r\n  \r\n    charsUsed += 1;\r\n\r\n    // The next tile is not the end of the board and is not empty, we can continue\r\n    if (row + 1 < payload.board.length && hasChar(payload.board, row + 1, payload.column)) {\r\n      continue;\r\n    }\r\n\r\n    if (charsUsed >= payload.playerCharsLength) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  const splitted = constructedWord.split('');\r\n  if (splitted.some(c => c !== '*') && splitted.some(c => c === '*')) {\r\n    return constructedWord;\r\n  }\r\n\r\n  return '';\r\n}\r\n\r\n/**\r\n * Make sure that the word we create doesn't have a char after it. Which makes it not a word then\r\n * possibly. If it is a word, it will probably be checked at a later point from the allWord array.\r\n * @param word The word we get from lexikon\r\n * @param columnMatch the board, which column we are in and from where the word starts\r\n */\r\nconst positionAfterCurrentWordIsEmpty = (word: string, columnMatch: ColumnMatch): boolean => {\r\n  if (columnMatch.row + word.length < columnMatch.board.length) {\r\n    if (hasChar(columnMatch.board, columnMatch.row + word.length, columnMatch.column)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nconst wordsThatMatchPositions = (payload: ColumnMatch): Array<MatchedWord> => {\r\n  return payload.allWords.reduce((accumulated, libraryWord) => {\r\n    if (libraryWord.length <= 1 || libraryWord.length > payload.constructedWord.length) {\r\n      return accumulated\r\n    }\r\n\r\n\r\n    if (!positionAfterCurrentWordIsEmpty(libraryWord, payload)) {\r\n      return accumulated\r\n    }\r\n\r\n    if (isWordFine(libraryWord, payload.constructedWord, payload.playerChars)) {\r\n        accumulated.push({\r\n          word: libraryWord,\r\n          direction: 'column',\r\n          row: payload.row,\r\n          column: payload.column,\r\n          points: 0,\r\n        })\r\n      }\r\n\r\n    return accumulated\r\n  }, [] as Array<MatchedWord>);\r\n}\r\n\r\n/**\r\n * @param playerChars \r\n * @param board \r\n * @param column \r\n */\r\nconst solve = (playerChars: string, board: Array<Array<Tile>>, column: number) => {\r\n  const result: Array<MatchedWord> = [];\r\n  \r\n  for (let row = 0; row < board.length; row++) {\r\n    if (row > 0 && hasChar(board, row - 1, column)) {\r\n      // We start words when there is nothing above\r\n      continue\r\n    }\r\n\r\n    const constructedWord: string = getConstructedWordFromBoard({\r\n      board, start: row, column, playerCharsLength: playerChars.length\r\n    })\r\n\r\n    if (constructedWord !== '') {\r\n      const matches = wordsThatMatchPositions({\r\n        allWords: WordHandler.Instance.getWordsWithAtLeastLength(constructedWord.length),\r\n        constructedWord: constructedWord,\r\n        playerChars: playerChars,\r\n        board: board,\r\n        row,\r\n        column\r\n      });\r\n\r\n      result.push(...matches\r\n        .filter(rowWord => wordIsValidInBoard(rowWord, board))\r\n        .map(matchedWord => {\r\n          return {\r\n            ...matchedWord,\r\n            points: countPointsHelper(matchedWord, board)\r\n          }\r\n        }))\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nconst setWordInBoard = (columnWord: MatchedWord, board: Array<Array<Tile>>) => {\r\n  for (let i = 0; i < columnWord.word.length; i++) {\r\n    if (board[columnWord.row + i][columnWord.column].final === false) {\r\n      board[columnWord.row + i][columnWord.column].char = columnWord.word[i];\r\n    }\r\n  }\r\n}\r\n\r\nconst removeWordFromBoard = (columnWord: MatchedWord, board: Array<Array<Tile>>) => {\r\n  for (let i = 0; i < columnWord.word.length; i++) {\r\n    if (board[columnWord.row + i][columnWord.column].final === false) {\r\n      board[columnWord.row + i][columnWord.column].char = '';\r\n    }\r\n  }\r\n}\r\n\r\nconst countPointsHelper = (columnWord: MatchedWord, board: Array<Array<Tile>>): number => {\r\n  setWordInBoard(columnWord, board);\r\n\r\n  let points = countPoints(board);\r\n\r\n  removeWordFromBoard(columnWord, board);\r\n\r\n  return points;\r\n}\r\n\r\nconst wordIsValidInBoard = (columnWord: MatchedWord, board: Array<Array<Tile>>) => {\r\n  setWordInBoard(columnWord, board);\r\n\r\n  const isValid = boardIsValid(board);\r\n\r\n  removeWordFromBoard(columnWord, board);\r\n\r\n  return isValid;\r\n}\r\n\r\nconst solveColumns = (board: Array<Array<Tile>>, chars: string): Array<MatchedWord> => {\r\n  const list: Array<MatchedWord> = []\r\n\r\n  for (let column = 0; column < board.length; column++) {\r\n    list.push(...solve(chars, board, column))\r\n  }\r\n\r\n  return list;\r\n}\r\n\r\n\r\nexport {\r\n  solveColumns,\r\n  getConstructedWordFromBoard,\r\n  positionAfterCurrentWordIsEmpty\r\n}","import { boardIsValid } from '../Confirmers/Confirmer';\r\nimport { MatchedWord, Tile } from '../Models/Tile';\r\nimport { countPoints } from './CountPoints';\r\nimport { WordHandler } from '../Library/wordHandler';\r\nimport { hasChar, isWordFine } from './SolverUtil';\r\n\r\ninterface RowMatch {\r\n  allWords: Array<string>;\r\n  constructedWord: string;\r\n  playerChars: string;\r\n  board: Array<Array<Tile>>;\r\n  row: number;\r\n  column: number;\r\n}\r\n\r\nconst getConstructedWordFromBoard = (payload: {\r\n  board: Array<Array<Tile>>, start: number, playerCharsLength: number, row: number,\r\n}): string => {\r\n  let charsUsed = 0;\r\n  let column = payload.start;\r\n  let constructedWord: string = '';\r\n  let index = 0;\r\n\r\n  for (; column < payload.board.length; column++, index++) {\r\n    if (hasChar(payload.board, payload.row, column)) {\r\n      constructedWord += payload.board[payload.row][column].char;\r\n      continue;\r\n    }\r\n\r\n    if (charsUsed < payload.playerCharsLength) {\r\n      constructedWord += '*';\r\n    }\r\n\r\n    charsUsed += 1;\r\n  \r\n    if (column + 1 < payload.board.length && hasChar(payload.board, payload.row, column + 1)) {\r\n      continue;\r\n    }\r\n\r\n    if (charsUsed >= payload.playerCharsLength) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  const splitted = constructedWord.split('');\r\n  if (splitted.some(c => c !== '*') && splitted.some(c => c === '*')) {\r\n    return constructedWord;\r\n  }\r\n\r\n  return '';\r\n}\r\n\r\nconst solve = (playerChars: string, board: Array<Array<Tile>>, row: number) => {\r\n  const result: Array<MatchedWord> = [];\r\n  \r\n  for (let column = 0; column < board.length; column++) {\r\n    if (column > 0 && hasChar(board, row, column - 1)) {\r\n      // We start words when there is nothing to the left\r\n      continue\r\n    }\r\n\r\n    const constructedWord: string = getConstructedWordFromBoard({\r\n      board: board, start: column, row: row, playerCharsLength: playerChars.length\r\n    });\r\n\r\n    if (constructedWord !== '') {\r\n      const matches = wordsThatMatchPositions({\r\n        allWords: WordHandler.Instance.getWordsWithAtLeastLength(constructedWord.length),\r\n        constructedWord: constructedWord,\r\n        playerChars: playerChars,\r\n        board: board,\r\n        row,\r\n        column\r\n      })\r\n\r\n      result.push(...matches\r\n        .filter(rowWord => wordIsValidInBoard(rowWord, board))\r\n        .map(matchedWord => {\r\n          return {\r\n            ...matchedWord,\r\n            points: countPointsHelper(matchedWord, board)\r\n          }\r\n        }))\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nconst positionAfterCurrentWordIsNotEmpty = (word: string, rowMatch: RowMatch): boolean => {\r\n  if (rowMatch.column + word.length < rowMatch.board.length) {\r\n    if (hasChar(rowMatch.board, rowMatch.row, rowMatch.column + word.length)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nconst wordsThatMatchPositions = (payload: RowMatch): Array<MatchedWord> => {\r\n  return payload.allWords.reduce((accumulated, libraryWord) => {\r\n    if (libraryWord.length <= 1 || libraryWord.length > payload.constructedWord.length) {\r\n      return accumulated\r\n    }\r\n\r\n    if (!positionAfterCurrentWordIsNotEmpty(libraryWord, payload)) {\r\n      return accumulated\r\n    }\r\n\r\n    if (isWordFine(libraryWord, payload.constructedWord, payload.playerChars)) {\r\n      accumulated.push({\r\n        word: libraryWord,\r\n        direction: 'row',\r\n        row: payload.row,\r\n        column: payload.column,\r\n        points: 0,\r\n      });\r\n    }\r\n\r\n    return accumulated\r\n  }, [] as Array<MatchedWord>)\r\n}\r\n\r\nconst setWordInBoard = (rowWord: MatchedWord, board: Array<Array<Tile>>) => {\r\n  try {\r\n    for (let i = 0; i < rowWord.word.length; i++) {\r\n      if (board[rowWord.row][rowWord.column + i].final === false) {\r\n        board[rowWord.row][rowWord.column + i].char = rowWord.word[i];\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(rowWord)\r\n    console.log(board[0][0])\r\n    console.log(board[5][13])\r\n    console.error(error)\r\n  }\r\n}\r\n\r\nconst removeWordFromBoard = (rowWord: MatchedWord, board: Array<Array<Tile>>) => {\r\n  for (let i = 0; i < rowWord.word.length; i++) {\r\n    if (board[rowWord.row][rowWord.column + i].final === false) {\r\n      board[rowWord.row][rowWord.column + i].char = '';\r\n    }\r\n  }\r\n}\r\n\r\nconst countPointsHelper = (rowWord: MatchedWord, board: Array<Array<Tile>>) => {\r\n  setWordInBoard(rowWord, board);\r\n\r\n  let points = countPoints(board);\r\n\r\n  removeWordFromBoard(rowWord, board);\r\n\r\n  return points;\r\n}\r\n\r\nconst wordIsValidInBoard = (rowWord: MatchedWord, board: Array<Array<Tile>>) => {\r\n  setWordInBoard(rowWord, board);\r\n\r\n  const isValid = boardIsValid(board);\r\n\r\n  removeWordFromBoard(rowWord, board);\r\n\r\n  return isValid;\r\n}\r\n\r\nconst solveRows = (board: Array<Array<Tile>>, chars: string): Array<MatchedWord> => {\r\n  const list: Array<MatchedWord> = [];\r\n\r\n  for (let row = 0; row < board.length; row++) {\r\n    list.push(...solve(chars, board, row));\r\n  }\r\n\r\n  return list;\r\n}\r\n\r\nexport {\r\n  solveRows\r\n}","import { solveColumns } from \"./ColumnSolver\";\r\nimport { solveRows } from \"./RowSolver\";\r\n\r\nexport const solve = (board, playerChars) => {\r\n  const result = [\r\n    ...solveColumns(board, playerChars), \r\n    ...solveRows(board, playerChars)\r\n    ]\r\n  postMessage(result);\r\n}\r\n"],"sourceRoot":""}